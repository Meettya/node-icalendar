// Generated by clinch 0.6.3
(function() {
  'use strict';
  
  var dependencies, sources, require, modules_cache = {};
  dependencies = {"Z14y8qH":{"./lib/icalendar":"18YwbV"},"18YwbV":{"assert":"MqNAu","util":"zYbj9","./base":"ZjLJJt","./index":"H3XKY"},"ZjLJJt":{"./icalendar":"18YwbV","./types":"X9DmA"},"H3XKY":{"./types":"X9DmA","./base":"ZjLJJt","./icalendar":"18YwbV","./rrule":"Z23ocoq","./parser":"qkHzA","./event":"6Wkjh","./timezone":"Z2oMYNS"},"X9DmA":{"./rrule":"Z23ocoq"},"Z23ocoq":{"./types":"X9DmA"},"qkHzA":{"assert":"MqNAu","util":"zYbj9","./types":"X9DmA","./base":"ZjLJJt","./icalendar":"18YwbV"},"6Wkjh":{"util":"zYbj9","./base":"ZjLJJt","./icalendar":"18YwbV","./rrule":"Z23ocoq"},"Z2oMYNS":{"assert":"MqNAu","util":"zYbj9","./base":"ZjLJJt","./rrule":"Z23ocoq"}};

  sources = {
"MqNAu": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/web_modules/assert.coffee 

/*
node.js assert shim
 */
module.exports = {
  equal: function(a, b) {
    if (a !== b) {
      throw Error("assert test fail! |" + a + "| isnt |" + b + "|");
    }
    return null;
  }
};

},
"zYbj9": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/web_modules/util.js 
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = function(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
};
},
"Z14y8qH": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/index.js 
exports = require('./lib/icalendar');

},
"18YwbV": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/icalendar.js 
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// 
// 
// Implement RFC5545 (iCalendar)
// see: http://tools.ietf.org/html/rfc5545
//

var assert = require('assert');
var util = require('util');

var CalendarObject = require('./base').CalendarObject;
var CalendarProperty = require('./base').CalendarProperty;
var schema = require('./base').schema;



var iCalendar = exports.iCalendar = function(empty) {
    CalendarObject.call(this, this, 'VCALENDAR');
    this.calendar = this;

    if(!empty) {
        this.addProperty('VERSION', '2.0');
        this.addProperty('PRODID', require('./index').PRODID);      
    }
}
util.inherits(iCalendar, CalendarObject);

iCalendar.prototype.events = function() { return this.components['VEVENT'] || []; }

iCalendar.prototype.timezone = function(tzid) {
    for(var i=0; i<this.components['VTIMEZONE'].length; ++i) {
        var tz = this.components['VTIMEZONE'][i];
        if(tz.getPropertyValue('TZID') == tzid)
            return tz;
    }
}



schema.VCALENDAR = {
    factory: iCalendar,
    valid_properties: [],
    required_properties: ['PRODID','VERSION'],
    valid_children: ['VEVENT'],
    required_children: []
};

// Unimplemented components...
schema.VTODO = {
    required_properties: ['DTSTAMP','UID']
};
schema.VJOURNAL = {
    required_properties: ['DTSTAMP','UID']
};
schema.VFREEBUSY = {
    required_properties: ['DTSTAMP','UID']
};
schema.VALARM = {
    required_properties: ['ACTION','TRIGGER']
};

},
"ZjLJJt": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/base.js 
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
//

var format_value = require('./types').format_value;

var schema = exports.schema = { };

var properties = exports.properties = {
    // Calendar properties
    CALSCALE:       { type: 'TEXT' },
    METHOD:         { type: 'TEXT' },
    PRODID:         { type: 'TEXT' },
    VERSION:        { type: 'TEXT' },

    // Descriptive component properties
    ATTACH:             { type: 'URI' },
    CATEGORIES:         { type: 'TEXT', list: true },
    CLASS:              { type: 'TEXT' },
    COMMENT:            { type: 'TEXT' },
    DESCRIPTION:        { type: 'TEXT' },
    GEO:                { type: 'FLOAT', list: true },
    LOCATION:           { type: 'TEXT' },
    'PERCENT-COMPLETE': { type: 'INTEGER' },
    PRIORITY:           { type: 'INTEGER' },
    RESOURCES:          { type: 'TEXT' },
    STATUS:             { type: 'TEXT' },
    SUMMARY:            { type: 'TEXT' },

    // Date and Time component properties
    COMPLETED: { type: 'DATE-TIME' },
    DTEND:     { type: 'DATE-TIME' },
    DUE:       { type: 'DATE-TIME' },
    DTSTART:   { type: 'DATE-TIME' },
    DURATION:  { type: 'DURATION' },
    FREEBUSY:  { type: 'PERIOD' },
    TRANSP:    { type: 'TEXT' },

    // Time Zone component properties
    TZID:         { type: 'TEXT' },
    TZNAME:       { type: 'TEXT' },
    TZOFFSETFROM: { type: 'UTC-OFFSET' },
    TZOFFSETTO:   { type: 'UTC-OFFSET' },
    TZURL:        { type: 'URI' },

    // Relationship component properties
    ATTENDEE:        { type: 'CAL-ADDRESS' },
    CONTACT:         { type: 'TEXT' },
    ORGANIZER:       { type: 'CAL-ADDRESS' },
    'RECURRENCE-ID': { type: 'DATE-TIME' },
    'RELATED-TO':    { type: 'TEXT' },
    URL:             { type: 'URI' },
    UID:             { type: 'TEXT' },

    // Recurrence component properties
    EXDATE: { type: 'DATE-TIME', list: true },
    RDATE:  { type: 'DATE-TIME', list: true },
    RRULE:  { type: 'RECUR' },

    // Alarm component properties
    ACTION:  { type: 'TEXT' },
    REPEAT:  { type: 'INTEGER' },
    TRIGGER: { type: 'DURATION' },

    // Change Management component properties
    CREATED:         { type: 'DATE-TIME' },
    DTSTAMP:         { type: 'DATE-TIME' },
    'LAST-MODIFIED': { type: 'DATE-TIME' },
    SEQUENCE:        { type: 'INTEGER' },

    // Miscellaneous component properties
    'REQUEST-STATUS': { type: 'TEXT' }
};



// Maximum number of octets in a single iCalendar line
var MAX_LINE = 75;



var CalendarObject = exports.CalendarObject = function(calendar, element) {
    this.calendar = calendar;
    this.element = element;
    this.components = {};
    this.properties = {};
}

// Create an element of the correct type
CalendarObject.create = function(element, calendar) {
    var factory = (schema[element] || {}).factory;
    return (factory !== undefined
             ? new factory(calendar)
             : new CalendarObject(calendar, element));
}

// Recursively generates a clone of some calendar object
CalendarObject.prototype.clone = function() {
    var obj = CalendarObject.create(this.element, this.calendar);

    for(var prop in this.properties)
        obj.addProperties(this.properties[prop]);

    var comp = this.getComponents();
    for(var i=0; i<comp.length; ++i)
        obj.addComponent(comp[i]);

    return obj;
}

CalendarObject.prototype.addProperties = function(props) {
    props.forEach(this.addProperty.bind(this));
}

CalendarObject.prototype.addProperty = function(prop, value, parameters) {
    if(!(prop instanceof CalendarProperty)) {
        if(value === undefined) return;
        prop = new CalendarProperty(prop, value, parameters);
    }
    else
        prop = prop.clone();

    this.properties[prop.name] = this.properties[prop.name] || [];
    this.properties[prop.name].push(prop);
    return prop;
}

// Replace an existing property or properties
CalendarObject.prototype.setProperty = function(prop, value, parameters) {
    this.removeProperty(prop instanceof CalendarProperty ? prop.name : prop);
    this.addProperty(prop, value, parameters);
}

CalendarObject.prototype.addComponent = function(comp) {
    if(!(comp instanceof CalendarObject)) {
        var factory = (schema[comp] || {}).factory;
        comp = factory !== undefined
                 ? new factory(this.calendar)
                 : new CalendarObject(this.calendar, comp);
    }

    // Create a copy of the component if it's from a different
    // calendar object to prevent changes from one place happening 
    // somewhere else as well
    if(comp.calendar && comp.calendar !== this.calendar)
        comp = comp.clone();

    this.components[comp.element] = this.components[comp.element] || [];
    this.components[comp.element].push(comp);
    comp.calendar = this.calendar;
    return comp;
}

CalendarObject.prototype.addComponents = function(comps) {
    comps.forEach(this.addComponent.bind(this));
}

CalendarObject.prototype.getComponents = function(type) {
    if(type === undefined) {
        var all = [];
        for(var c in this.components)
            all = all.concat(this.components[c]);

        return all;
    }

    return this.components[type] || [];
}

CalendarObject.prototype.getProperty = function(prop, i) {
    return (this.properties[prop] || [])[i || 0];
}

CalendarObject.prototype.getProperties = function(prop) {
    return this.properties[prop] || [];
}

CalendarObject.prototype.getPropertyValue = function(prop, i) {
    return (this.getProperty(prop, i) || {}).value;
}

CalendarObject.prototype.removeProperty = function(prop) {
    delete this.properties[prop];
}

CalendarObject.prototype.validate = function() {
    var self = this;
    var _schema = schema[self.element];
    if(_schema && _schema.required_properties) {
        _schema.required_properties.forEach(function(req) {
            if(!self.getPropertyValue(req))
                throw new Error(req+" is a required property of "+self.element);
        });
    }

    for(var type in self.components) {
        self.components[type].forEach(function(comp) {
            comp.validate();
        });
    }
}

CalendarObject.prototype.toString = function() {
    // Make sure output always includes a VCALENDAR object
    var output;
    if(this.element == 'VCALENDAR')
        output = this.format();
    else {
        var ical = new (require('./icalendar').iCalendar)();
        ical.addComponent(this);
        output = ical.format()
    }

    output.push(''); // <-- Add empty element to ensure trailing CRLF
    return output.join('\r\n');
}

CalendarObject.prototype.format = function() {
    var lines = ['BEGIN:'+this.element];
    for(var i in this.properties) {
        this.properties[i].forEach(function(prop) {
            lines.push.apply(lines, prop.format());
        });
    }

    for(var comp in this.components) {
        var comp = this.components[comp];
        for(var i=0; i < comp.length; ++i)
            lines.push.apply(lines, comp[i].format());
    }

    lines.push('END:'+this.element);
    return lines;
}




var CalendarProperty = exports.CalendarProperty = function(name, value, parameters) {
    var propdef = properties[name];

    this.type = propdef && propdef.type ? propdef.type : 'TEXT';
    this.name = name;
    this.value = value;
    this.parameters = parameters || {};
}

CalendarProperty.prototype.clone = function() {
    var obj = new CalendarProperty(this.name, this.value);
    obj.type = this.type;

    // TODO: Copy type and value instances in the case of objects, dates, arrays
    for(var param in this.parameters)
        obj.parameters[param] = this.parameters[param];

    return obj;
}

CalendarProperty.prototype.getParameter = function(param) {
    return this.parameters[param];
}

CalendarProperty.prototype.setParameter = function(param, value) {
    this.parameters[param] = value;
}

CalendarProperty.prototype.format = function() {
    var params = [];
    for(var k in this.parameters)
        params.push(k+'='+this.parameters[k]);

    if(params.length)
        params = ';'+params.join(';');

    var data = new Buffer(this.name+params+':'+format_value(this.type, this.value, this.parameters));
    var pos = 0, len;
    var output = [];
    while(true) {
        len = MAX_LINE;
        if(pos+len >= data.length)
            len = data.length-pos;

        // We're in the middle of a unicode character if the high bit is set and
        // the next byte is 10xxxxxx (or 0x80).  Don't split it in half.
        // Wind backward until we find the start character...
        while((data[pos+len] & 0xc0) == 0x80)
            len--;

        output.push(data.toString('utf8', pos, pos+len));

        if(pos+len >= data.length)
            break;

        // Insert the space for the start of the next line...
        pos += len-1;
        data[pos] = 0x20;
    }

    return output;
}

},
"H3XKY": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/index.js 
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// 
// 
// Implement RFC5545 (iCalendar)
// see: http://tools.ietf.org/html/rfc5545
//


exports.format_value = require('./types').format_value;
exports.parse_value = require('./types').parse_value;
exports.RRule = require('./rrule').RRule;

exports.parse_calendar = require('./parser').parse_calendar;
exports.ParseError = require('./parser').ParseError;

exports.CalendarObject = require('./base').CalendarObject;
exports.CalendarProperty = require('./base').CalendarProperty;


exports.iCalendar = require('./icalendar').iCalendar;
exports.VEvent = require('./event').VEvent;
exports.VTimezone = require('./timezone').VTimezone;



exports.PRODID = '-//Tri Tech Computers//node-icalendar//EN';

},
"X9DmA": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/types.js 
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
//

var RRule = require('./rrule').RRule;

function pad(n,d) {
    d = d || 2;
    var neg = n < 0;
    if(neg) n *= -1;
    n = n.toString();

    var zeroes = '000000000000000000';
    return (neg ? '-' : '')+zeroes.substr(0,d-n.length)+n;
}

var _types = {
    'BINARY': {
        format: function(value) {
            return value.toString('base64');
        },
        parse: function(value) {
            return new Buffer(value, 'base64');
        }
    },
    'BOOLEAN': {
        format: function(value) {
            return value ? "TRUE" : "FALSE";
        },
        parse: function(value) {
            return value.toUpperCase() == "TRUE";
        }
    },
    'CAL-ADDRESS': {
        format: function(value) {
            var v = value.toString();
            if(v.lastIndexOf("mailto:") != 0)
                v = "mailto:"+v;
            return v;
        }
    },
    'DATE': {
        format: function(value) {
            if(!(value instanceof Date))
                value = new Date(value);

            return value.getFullYear()
                    +pad(value.getMonth()+1)
                    +pad(value.getDate());
        },
        parse: function(value) {
            var dt = new Date(
                        parseInt(value.substr(0,4), 10),
                        parseInt(value.substr(4,2), 10)-1,
                        parseInt(value.substr(6,2), 10), 0,0,0);
            dt.date_only = true;
            return dt;
        }
    },
    'DATE-TIME': {
        // YYYYMMDDTHHMMSS
        //  TODO: Support local time with TZID values
        format: function(value, parameters) {
            if(!(value instanceof Date))
                value = new Date(value);

            if(value.date_only || parameters['VALUE'] === 'DATE')
                return format_value('DATE', value);

            return value.getUTCFullYear()
                    +pad(value.getUTCMonth()+1)
                    +pad(value.getUTCDate())
                    +'T'+format_value('TIME', value);
        },
        parse: function(value, parameters, calendar) {
            if(parameters['VALUE'] === 'DATE' || value.length <= 8)
                return _types['DATE'].parse(value);

            var tz = parameters['TZID'];
            var d = [parseInt(value.substr(0,4), 10),
                         parseInt(value.substr(4,2), 10),
                         parseInt(value.substr(6,2), 10),
                         parseInt(value.substr(9,2), 10),
                         parseInt(value.substr(11,2), 10),
                         parseInt(value.substr(13,2), 10)];
            var utc = value.length > 15 ? value[15] === 'Z' : false;

            if(tz !== undefined) {
                var tzobj = calendar.timezone(tz);
                if(!tzobj)
                    throw new Error("Unable to load TZ data for "+tz);
                return tzobj.fromLocalTime(d);
            }

            // Adjust month to make JS date happy...
            d[1] -= 1;

            if(utc)
                return new Date(Date.UTC.apply(null, d));
            else
                return new Date(d[0], d[1], d[2], d[3], d[4], d[5]);
        }
    },
    'DURATION': {
        format: function(value) {
            // Duration values from JS should be an integer number of seconds
            var neg = value < 0;
            if(neg) value *= -1;

            var w = Math.floor(value/(60*60*24*7)); value -= w*60*60*24*7;
            var d = Math.floor(value/(60*60*24));   value -= d*60*60*24;
            var h = Math.floor(value/(60*60));      value -= h*60*60;
            var m = Math.floor(value/60);           value -= m*60;
            var s = value;

            var dur = ['P'];
            if(neg) dur.unshift('-');
            if(w) dur.push(w+'W');
            if(d) dur.push(d+'D');
            if((h||m||s)) dur.push('T');
            if(h) dur.push(h+'H');
            if(m) dur.push(m+'M');
            if(s) dur.push(s+'S');
            return dur.join('');
        },
        parse: function(value) {
            var match = /(-)?P(\d+W)?(\d+D)?(?:T(\d+H)?(\d+M)?(\d+S)?)?/.exec(value).slice(1);
            var mul = [ -1, 60*60*24*7, 60*60*24, 60*60, 60, 1 ];
            var dur = 0;

            for(var i=1; i < match.length; ++i) {
                if(match[i] !== undefined) dur += parseInt(match[i], 10) * mul[i];
            }

            if(match[0] !== undefined) dur *= mul[0];

            return dur;
        }
    },
    'FLOAT': {
        format: function(value) { return value.toString(); },
    },
    'INTEGER': {
        format: function(value) { return value.toString(); },
    },
    'PERIOD': {
        format: function(value) {
            var start = format_value('DATE-TIME', value[0]);
            var end = format_value(value[1] instanceof Date ? 'DATE-TIME' : 'DURATION', value[1]);
            return start+'/'+end;
        }
    },
    'RECUR': {
        format: function(value) {
            return (value instanceof RRule ? value : new RRule(value)).toString();
        },
        parse: function(value) { return RRule.parse(value); }
    },
    'TEXT': {
        format: function(value) {
            return (value || '').toString().replace(/([\\,;])/g, "\\$1").replace(/\n/g, "\\n");
        },
        parse: function(value) {
            return value.replace(/\\([\\,;])/g, "$1")
                        .replace(/\\[nN]/g, '\n');
        }
    },
    'TIME': {
        format: function(value) {
            if(!(value instanceof Date))
                value = new Date(value);

            return pad(value.getUTCHours())
                    +pad(value.getUTCMinutes())
                    +pad(value.getUTCSeconds())
                    +'Z';
        },
        parse: function(value) {
            var utc = value.length > 6 ? value[6] === 'Z' : false;
            if(utc)
                return new Date(Date.UTC(0,0,0,
                        parseInt(value.substr(0, 2), 10),
                        parseInt(value.substr(2, 2), 10),
                        parseInt(value.substr(4, 2), 10)));
            else
                return new Date(0,0,0,
                        parseInt(value.substr(0, 2), 10),
                        parseInt(value.substr(2, 2), 10),
                        parseInt(value.substr(4, 2), 10));
        }
    },
    'URI': {
        format: function(value) { return value.toString(); },
    },
    'UTC-OFFSET': {
        format: function(value) {
            var west = value < 0;
            if(west) value *= -1;
            return (west ? '-' : '+')+pad(value, 4);
        }
    }
};


var format_value = exports.format_value = function(type, value, parameters) {
    if(value === undefined)
        return '';

    var fmt = _types[type || 'TEXT'];
    if(fmt === undefined)
        throw Error("Invalid iCalendar datatype: "+type);

    // PERIOD is a corner case here; it's an array of two values
    if(Array.isArray(value) && type !== 'PERIOD'
            || type === 'PERIOD' && value[0] && Array.isArray(value[0]))
        return value.map(function(v) { return fmt.format(v, parameters || {}); }).join(',');
    else
        return fmt.format(value, parameters || {});
}

var parse_value = exports.parse_value = function(type, value, parameters, calendar, expect_list) {
    if(expect_list)
        return value.split(',').map(function(x) { return parse_value(type, x, parameters, calendar); });

    var fmt = _types[type || 'TEXT'];
    if(fmt === undefined)
        throw Error("Invalid iCalendar datatype: "+type);

    // Handle wrong value type
    parameters = parameters || {};
    var otherFmt = parameters.VALUE && _types[parameters.VALUE];
    if (otherFmt) fmt = otherFmt;
    return fmt.parse ? fmt.parse(value, parameters, calendar) : value;
}

},
"Z23ocoq": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/rrule.js 
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
//
//
// NB: All calculations here happen using the UTC portion of a datetime object
//   as if it were the local time. This is done to reuse the TZ-agnostic date
//   calculations provided to us. Without this, performing date calculations
//   across local DST boundaries would yield surprising results.
//


var types = require('./types');

var SUPPORTED_PARTS = ['FREQ','INTERVAL','COUNT','UNTIL','BYDAY','BYMONTH','BYMONTHDAY'];
var WKDAYS = ['SU','MO','TU','WE','TH','FR','SA'];

function to_utc_date(dt) {
    if(Array.isArray(dt)) {
        dt = dt.slice(0); // Make a copy...
        dt[1]--; // Fixup month for Date.UTC()
    }
    else
        dt = [dt.getFullYear(), dt.getMonth(), dt.getDate(),
        dt.getHours(), dt.getMinutes(), dt.getSeconds(), dt.getMilliseconds()];

    return new Date(Date.UTC.apply(null, dt));
    //udt.date_only = dt.date_only;
    return udt;
}

function from_utc_date(udt) {
    var dt = new Date(udt.getUTCFullYear(), udt.getUTCMonth(), udt.getUTCDate(),
        udt.getUTCHours(), udt.getUTCMinutes(), udt.getUTCSeconds(), udt.getUTCMilliseconds());
    //dt.date_only = udt.date_only;
    return dt;
}

// Return only the whole number portion of a number
function trunc(n) {
    return n < 0 ? Math.ceil(n) : Math.floor(n);
}

// These are more comfy to type...
function y(dt)   {  return dt.getUTCFullYear();     }
function m(dt)   {  return dt.getUTCMonth()+1;      }
function d(dt)   {  return dt.getUTCDate();         }
function hr(dt)  {  return dt.getUTCHours();        }
function min(dt) {  return dt.getUTCMinutes();      }
function sec(dt) {  return dt.getUTCSeconds();      }
function ms(dt)  {  return dt.getUTCMilliseconds(); }

function set_y(dt, v)   {  dt.setUTCFullYear(v);     return dt;  }
function set_m(dt, v)   {  dt.setUTCMonth(v-1);      return dt;  }
function set_d(dt, v)   {  dt.setUTCDate(v);         return dt;  }
function set_hr(dt, v)  {  dt.setUTCHours(v);        return dt;  }
function set_min(dt, v) {  dt.setUTCMinutes(v);      return dt;  }
function set_sec(dt, v) {  dt.setUTCSeconds(v);      return dt;  }
function set_ms(dt, v)  {  dt.setUTCMilliseconds(v); return dt;  }

function add_y(dt, v)   {  return set_y(dt, y(dt)+v);      }
function add_m(dt, v)   {  return set_m(dt, m(dt)+v);      }
function add_d(dt, v)   {  return set_d(dt, d(dt)+v);      }
function add_hr(dt, v)  {  return set_hr(dt, hr(dt)+v);    }
function add_min(dt, v) {  return set_min(dt, min(dt)+v);  }
function add_sec(dt, v) {  return set_sec(dt, sec(dt)+v);  }

// First of the month
function fst(dt)    {
    return new Date(y(dt), m(dt)-1, 1);
}

// Day of week (0-6), adjust for the start of week
function wkday(dt) {
    return dt.getUTCDay();
}

// Return the number of days between dt1 and dt2
function daydiff(dt1, dt2) {
    return (dt2-dt1)/(1000*60*60*24);
}

// Week of year
function wk(dt)  {  
    var jan1 = new Date(Date.UTC(y(dt), 0, 1));
    return trunc(daydiff(jan1, dt)/7);
}

// Week of month
function m_wk(dt, wkst) {
    return (0 | d(dt)/7) + (d(dt) % 7 === 0 ? 0 : 1);
}


var RRule = exports.RRule = function(rule, options, dtend) {
    if(options instanceof Date)
        options = { DTSTART: options, DTEND: dtend };

    options = options || {};
    this.start = options.DTSTART ? to_utc_date(options.DTSTART) : null;
    this.end = options.DTEND ? to_utc_date(options.DTEND) : null;

    this.exceptions = options.EXDATE || [];

    if(typeof rule === 'string')
        rule = RRule.parse(rule);

    this.rule = {};
    for(var i in (rule||{})) {
        if(SUPPORTED_PARTS.indexOf(i) == -1)
            throw new Error(i+" is not currently supported!");

        this.rule[i] = RULE_PARTS[i]
                ? RULE_PARTS[i].parse(rule[i])
                : rule[i];
    }
}

RRule.parse = function(value) {
    var parts = value.split(/=|;/);
    var rrule = {};
    for(var i=0; i<parts.length; i+=2) {
        rrule[parts[i]] = parts[i+1];
    }
    return rrule;
}

RRule.prototype.setFrequency = function(freq) {
    this.rule.FREQ = freq;
}

RRule.prototype.valueOf = function() { return this.rule; }

RRule.prototype.toString = function() {
    // FREQ comes first, as per spec
    var out = [ 'FREQ='+this.rule.FREQ ];
    for(var k in this.rule) {
        if(k=='FREQ') continue;

        out.push(k+'='+((RULE_PARTS[k] || {}).format
                ? RULE_PARTS[k].format(this.rule[k])
                : this.rule[k]));
    }
    return out.join(';');
}

// Return the next occurrence after dt
RRule.prototype.next = function(after) {
    after = after && to_utc_date(after);

    // Events don't occur before the start or after the end...
    if(!after || after < this.start)
        after = new Date(this.start.valueOf() - 1);
    if(this.until && after > this.until) return null;

    var freq = FREQ[this.rule.FREQ];
    if(!freq)
        throw new Error(this.rule.FREQ+' recurrence is not supported');

    NextOccurs:
    while(true) {
        var next = freq.next(this.rule, this.start, after);

        // Exclude EXDATES
        var nextInLocal = from_utc_date(next);
        for(var i=0; i < this.exceptions.length; i++) {
            var exdate = this.exceptions[i];
            if((exdate.valueOf() == nextInLocal.valueOf())
                    || (exdate.date_only && y(to_utc_date(exdate)) == y(nextInLocal)
                    && m(to_utc_date(exdate)) == m(nextInLocal) && d(to_utc_date(exdate)) == d(nextInLocal))) {
                after = next;
                continue NextOccurs;
            }
        }

        break;
    }

    // Date is off the end of the spectrum...
    if(this.until && next > this.until)
        return null;

    if(this.rule.COUNT && this.count_end !== null) {
        if(this.count_end === undefined) {
            // Don't check this while we're trying to compute it...
            this.count_end = null;
            this.count_end = this.nextOccurences(this.rule.COUNT).pop();
        }

        if(next > to_utc_date(this.count_end))
            return null;
    }

    if(this.rule.UNTIL && next > to_utc_date(this.rule.UNTIL))
        return null;

    return from_utc_date(next);
}

RRule.prototype.nextOccurences = function(after, count_or_until) {
    if(arguments.length === 1) {
        count_or_until = after;
        after = undefined;
    }

    var arr = [];
    if(count_or_until instanceof Date) {
        while(true) {
            after = this.next(after);
            if(after && after <= count_or_until)
                arr.push(after);
            else
                break;
        }
    }
    else {
        while(count_or_until-- && after !== null) {
            after = this.next(after);
            if(after)
                arr.push(after);
        }
    }
    return arr;
}


var RULE_PARTS = {
    INTERVAL: {
        parse: function(v) { return parseInt(v,10); }
    },
    UNTIL: {
        parse: function(v) {
            if(v instanceof Date) return v;
            return types.parse_value('DATE-TIME', v);
        },
        format: function(v) { return types.format_value('DATE-TIME', v); }
    },
    FREQ: {
        parse: function(v) { return v; },
    },
    BYMONTH: {
        parse: function(v) {
            if(typeof v === 'number') return [v];

            return v.split(',').map(function(mo) {
                return parseInt(mo,10);
            });
        },
        format: function(v) {
            return v.join(',');
        }
    },
    BYDAY: {  // 2TH (second thursday) -> [2,4]
        parse: function(v) {
            var days = v.split(',').map(function(day) {
                var m = day.match(/([+-]?\d)?(SU|MO|TU|WE|TH|FR|SA)/);
                return [parseInt(m[1],10)||0, WKDAYS.indexOf(m[2])];
            });

            days.sort(function(d1, d2) {
                // Sort by week, day of week
                if(d1[0] == d2[0])
                    return d1[1] - d2[1];
                else
                    return d1[0] - d2[0];
            });

            return days;
        },
        format: function(v) {
            return v.map(function(day) {
                return (day[0] || '')+WKDAYS[day[1]];
            }).join(',');
        }
    },
    EXDATE: {
      parse: function(v) {
        return v.split(',').map(function(dt) {
          return dt.length == 8 ? types.parse_value('DATE', dt) : types.parse_value('DATE-TIME', dt);
        });
      },
      format: function(v) {
        return v.map(function(dt) {
            return types.format_value(dt.date_only ? 'DATE' : 'DATE-TIME', dt);
        }).join(',');
      }
    }
};

// These parts use the same format...
RULE_PARTS['BYMONTHDAY'] = RULE_PARTS['BYMONTH'];
RULE_PARTS['COUNT'] = RULE_PARTS['INTERVAL'];

var FREQ = {
    DAILY: {
        next: function(rule, start, after) {
            var next = new Date(after);
            set_hr(next, hr(start));
            set_min(next, min(start));
            set_sec(next, sec(start));
            set_ms(next, ms(start));

            var interval = rule.INTERVAL || 1;

            // Adjust for interval...
            var mod_days = trunc(daydiff(next, start)) % interval;
            if(mod_days)
                add_d(next, interval - mod_days);

            for(var i=0; i<2; ++i) {
                next = byday(rule.BYDAY, next, after);

                if(next.valueOf() > after.valueOf())
                    break;

                add_d(next, interval);
            }

            return next;
        }
    },
    WEEKLY: {
        next: function(rule, start, after) {
            var next = new Date(after);
            set_hr(next, hr(start));
            set_min(next, min(start));
            set_sec(next, sec(start));
            set_ms(next, ms(start));

            var interval = rule.INTERVAL || 1;

            // Adjust for interval...
            var mod_weeks = trunc(daydiff(start, next) / 7) % interval;
            if(mod_weeks)
                add_d(next, (interval - mod_weeks) * 7);

            while(true) {
                next = byday(rule.BYDAY, next, after);

                // Fall back to the start day of the week
                if (!rule.BYDAY || !rule.BYDAY.length) {
                  startDayOfWeek = wkday(start);
                  nextDayOfWeek = wkday(next);

                  // Always move backwards to the start day of week
                  if (nextDayOfWeek > startDayOfWeek)
                    add_d(next, startDayOfWeek - nextDayOfWeek);
                  else if (startDayOfWeek > nextDayOfWeek)
                    add_d(next, startDayOfWeek - nextDayOfWeek - 7);
                }


                if(next.valueOf() > after.valueOf()
                        && check_bymonth(rule.BYMONTH, next))
                    break;

                add_d(next, interval * 7);
            }

            return next;
        }
    },
    MONTHLY: {
        next: function(rule, start, after) {
            var next = new Date(after);
            set_hr(next, hr(start));
            set_min(next, min(start));
            set_sec(next, sec(start));
            set_ms(next, ms(start));

            var interval = rule.INTERVAL || 1;

            // Adjust interval to be correct
            var delta = (m(next) - m(start)) + (y(next) - y(start)) * 12;
            if(delta % interval)
                add_m(next, interval - (delta % interval));


            for(var i=0; i<2; ++i) {
                if (i) set_d(next, 1); // Start at the beginning of the month for subsequent months
                next = byday(rule.BYDAY, next, after);
                next = bymonthday(rule.BYMONTHDAY, next, after);

                // Fall back to the start day of the month
                if ((!rule.BYDAY || !rule.BYDAY.length) && (!rule.BYMONTHDAY || !rule.BYMONTHDAY.length))
                  set_d(next, d(start));

                if(next.valueOf() > after.valueOf())
                    break;

                add_m(next, interval);
            }

            return next;
        }
    },
    YEARLY: {
        next: function(rule, start, after) {
            // Occurs every N years...
            var next = new Date(after);
            // TODO: Add actual byhour/minute/second methods
            set_hr(next, hr(start));
            set_min(next, min(start));
            set_sec(next, sec(start));
            set_ms(next, ms(start));

            var interval = rule.INTERVAL || 1;

            var mod_year = (y(after) - y(start)) % interval;
            if(mod_year)
                // We're not in a valid year, move to the next valid year
                add_y(next, interval - mod_year);


            for(var i=0; i<2; ++i) {
                next = bymonth(rule.BYMONTH, next);
                next = bymonthday(rule.BYMONTHDAY, next, after);
                next = byday(rule.BYDAY, next, after);

                // Fall back the the start month and day of the month
                if (!rule.BYMONTH || !rule.BYMONTH.length)
                  set_m(next, m(start));
                if ((!rule.BYDAY || !rule.BYDAY.length) && (!rule.BYMONTHDAY || !rule.BYMONTHDAY.length))
                  set_d(next, d(start));

                // Don't loop back again if we found a new date
                if(next.valueOf() > after.valueOf())
                    break;

                set_d(set_m(add_y(next, interval), 1), 1);
            }

            return next;
        }
    }
};

function sort_dates(dateary) {
    return dateary.sort(function(dt1, dt2) {
        if(dt1 === null && dt2 === null) return 0;
        if(dt1 === null) return 1;
        if(dt2 === null) return -1;

        return dt1.valueOf() - dt2.valueOf();
    });
}

// Check that a particular date is within the limits
// designated by the BYMONTH rule
function check_bymonth(rules, dt) {
    if(!rules || !rules.length) return true;
    return rules.indexOf(m(dt)) !== -1;
}

// Advance to the next month that satisfies the rule...
function bymonth(rules, dt) {
    if(!rules || !rules.length) return dt;

    var candidates = rules.map(function(rule) {
        var delta = rule-m(dt);
        if(delta < 0) delta += 12;

        var newdt = add_m(new Date(dt), delta);
        set_d(newdt, 1);
        return newdt;
    });
    
    var newdt = sort_dates(candidates).shift();
    return newdt || dt;
}


function bymonthday(rules, dt, after) {
    if(!rules || !rules.length) return dt;

    var candidates = rules.map(function(rule) {
        var newdt = set_d(new Date(dt), rule);
        return (newdt.valueOf() <= after.valueOf() ? null : newdt);
    });

    var newdt = sort_dates(candidates).shift();
    return newdt || dt;
}


// Advance to the next day that satisfies the byday rule...
function byday(rules, dt, after) {
    if(!rules || !rules.length) return dt;

    // Generate a list of candiDATES. (HA!)
    var candidates = rules.map(function(rule) {
        // Align on the correct day of the week...
        var days = rule[1]-wkday(dt);
        if(days < 0) days += 7;
        var newdt = add_d(new Date(dt), days);

        if(rule[0] > 0) {
            var wk = 0 | ((d(newdt) - 1) / 7) + 1;
            if(wk > rule[0]) return null;

            add_d(newdt, (rule[0] - wk) * 7);
        }
        else if(rule[0] < 0) {
            // Find all the matching days in the month...
            var dt2 = new Date(newdt);
            var days = [];
            while(m(dt2) === m(newdt)) {
                days.push(d(dt2));
                add_d(dt2, 7);
            }

            // Then grab the nth from the end...
            set_d(newdt, days.reverse()[(-rule[0])-1]);
        }

        // Ignore if it's a past date...
        if (newdt.valueOf() <= after.valueOf()) return null;

        return newdt;
    });

    // Select the date occurring next...
    var newdt = sort_dates(candidates).shift();
    return newdt || dt;
}

},
"qkHzA": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/parser.js 
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
//

var assert = require('assert');
var util = require('util');
var types = require('./types');

var CalendarObject = require('./base').CalendarObject;
var schema = require('./base').schema;
var properties = require('./base').properties;

var iCalendar = require('./icalendar').iCalendar;

var parse_value = types.parse_value;
var format_value = types.format_value;



var ParseError = exports.ParseError = function() {
    Error.apply(this, arguments);
}
util.inherits(ParseError, Error);



function expect(expect_element, expect_value, next_state) {
    // Return a function that expects a certain element and value
    return function(element, value, parameters) {
        if(element != expect_element)
            throw new ParseError("Expected "+expect_element+" got "+element);

        if(expect_value && expect_value != value)
            throw new ParseError("Expected "+expect_value+" got "+value);
       
        return next_state;
    }
}

function parse_component(component, next_state) {
    // Parse an icalendar object
    var cal = component.calendar;
    return function this_state(element, value, parameters) {
        if(element == 'BEGIN') {
            var factory = (schema[value] || {}).factory;
            var child = factory !== undefined
                    ? new factory(cal)
                    : new CalendarObject(cal, value);

            return parse_component(child, function() {
                component.addComponent(child);
                // Forward this call onto our next state to process
                //  the current input record
                return this_state.apply(this, arguments);
            });
        }

        else if(element == 'END') {
            return next_state;
        }

        else {
            var prop = properties[element] || {};
            value = parse_value(prop.type, value, parameters, cal, prop.list);
            component.addProperty(element, value, parameters);
            return this_state;
        }
    }
}

PROP_NAME = 0;
PARAM_NAME = 1;
PARAM_VALUE = 2;
MAYBE_QUOTED_PARAM = 3;
QUOTED_PARAM_VALUE = 4;
PARAM_OR_VALUE = 5;
PROP_VALUE = 6;

function parse_record(rec) {
    var propname;
    var params = {};
    var state = PROP_NAME;
    var lastpos = 0;

    var current_param;

    // Switch state and bookmark the current position
    function newstate(s) {
        state = s;
        lastpos = i+1;
    }
    
    // Return the accumulated string since the last state change
    function str() {
        return rec.substr(lastpos, i - lastpos);
    }

    var i=0, j=rec.length;
    for(; i<j; ++i) {
        var ch = rec[i];
        switch(state) {
        case PROP_NAME:
            if(ch == ':' || ch == ';') {
                propname = str();
                state = PARAM_OR_VALUE;
                --i; // Re-evaluate
            }
            break;

        case PARAM_OR_VALUE:
            if(ch == ':')
                newstate(PROP_VALUE);
            else if(ch == ';')
                newstate(PARAM_NAME);
            else
                throw new Error("Parse error");
            break;

        case PARAM_NAME:
            if(ch == '=') {
                current_param = str();
                newstate(MAYBE_QUOTED_PARAM);
            }
            break;

        case MAYBE_QUOTED_PARAM:
            if(ch == '"')
                newstate(QUOTED_PARAM_VALUE);
            else
                state = PARAM_VALUE;

            break;

        case PARAM_VALUE:
            if(ch == ':' || ch == ';') {
                params[current_param] = str();
                state = PARAM_OR_VALUE;
                --i; // Re-evaluate
            }
            break;

        case QUOTED_PARAM_VALUE:
            if(ch == '"') {
                params[current_param] = str();
                state = PARAM_OR_VALUE;
            }
            break;

        case PROP_VALUE:
            // Done...
            i=j;
            break;

        default:
            throw new Error("Invalid parser state");
        }
    }

    return [ propname, str(), params ];
}

// Parse iCalendar formatted data and return an iCalendar object
//
// The second argument is an optional calendar object containing VTIMEZONE
// data to aid in the correct conversion of dates
exports.parse_calendar = function(data, timezone) {
    data = data.split(/\r?\n/);
    var calendar = new iCalendar(true);
    if(timezone) {
        if(typeof timezone === 'string')
            timezone = exports.parse_calendar(timezone);

        if(timezone instanceof iCalendar) {
            var tzs = timezone.getComponents('VTIMEZONE');
            for(var i=0; i<tzs.length; ++i)
                calendar.addComponent(tzs[i]);
        }
        else
            calendar.addComponent(tzs[i]);
    }
    var state = expect("BEGIN", "VCALENDAR", parse_component(calendar));

    for(var i=0; i<data.length-1; ++i) {
        if(!data[i].length)
            continue;
            
        if(state === undefined)
            throw new ParseError("Mismatched BEGIN/END tags");

        // Peek ahead to find line continuations...
        var j = i;
        while(j+1<data.length && (data[j+1][0] === ' ' || data[j+1][0] === '\t'))
            ++j;

        var record = data[i];
        if(j != i) {
            var d = data.slice(i, j+1);
            for(var k=1; k<d.length; ++k)
                // Strip out the extra space...
                d[k] = d[k].substr(1);
            record = d.join('');
            i = j;
        }

        state = state.apply(null, parse_record(record));
    }

    if(state !== undefined)
        throw new ParseError("Unable to parse calendar data; END:VCALENDAR not found!");

    return calendar;
}

},
"6Wkjh": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/event.js 
"use strict";
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// 

var util = require('util');

var CalendarObject = require('./base').CalendarObject;
var schema = require('./base').schema;

var iCalendar = require('./icalendar').iCalendar;

var RRule = require('./rrule').RRule;



var VEvent = exports.VEvent = function(calendar, uid) {
    if(!(calendar instanceof iCalendar) && calendar != null) {
        uid = calendar;
        calendar = null;
    }
    CalendarObject.call(this, calendar, 'VEVENT');

//    TODO: Move validation to its own method
//    if(uid === undefined)
//        throw Error("UID is a required parameter");

    if(uid !== undefined) {
        this.addProperty('DTSTAMP', new Date());
        this.addProperty('UID', uid);
    }
}
util.inherits(VEvent, CalendarObject);

VEvent.prototype.setSummary = function(summ) {
    this.addProperty('SUMMARY', summ);
}

VEvent.prototype.setLocation = function(loc) {
    this.addProperty('LOCATION', loc);
}

VEvent.prototype.setDescription = function(desc) {
    this.addProperty('DESCRIPTION', desc);
}

VEvent.prototype.setDate = function(start, end) {
    this.addProperty('DTSTART', start);
    if(end instanceof Date)
        this.addProperty('DTEND', end);
    else
        this.addProperty('DURATION', end);
}

VEvent.prototype.rrule = function() {
    var rr = this.getPropertyValue('RRULE');
    if(!rr) return null;

    var exceptions = [];
    var ex, i=0;
    while(ex = this.getPropertyValue('EXDATE', i++))
        exceptions.push.apply(exceptions, ex);

    return new RRule(rr, {
        DTSTART: this.getPropertyValue('DTSTART'),
        DTEND: this.getPropertyValue('DTEND'),
        EXDATE: exceptions
    });
}

VEvent.prototype.inTimeRange = function(start, end) {
    var rr = this.rrule();
    if(rr) {
        var next = rr.next(start);
        return (next !== null && (!end || next <= end));
    }

    var dtstart = this.getPropertyValue('DTSTART');
    var dtend = this.getPropertyValue('DTEND');
    if(!dtend) {
        var duration = this.getPropertyValue('DURATION');
        if(duration === 0)
            // Special case for zero-duration, as per RFC4791
            return (!start || start <= dtstart) && (!end || end > dtstart);

        else if(duration)
            dtend = new Date(dtstart.valueOf() + this.getPropertyValue('DURATION')*1000);
        else 
            dtend = new Date(dtstart.valueOf() + 24*60*60*1000); // +1 day
    }

    return (!start || start < dtend) && (!end || end > dtstart);
}

// Respond to this invitation (assumes this is an invitation)
//
// fromuser: URL for the user, usually in the form mailto:bob@example.com
// status: true, false, 'ACCEPTED', 'DECLINED', 'TENTATIVE', or as per RFC5545
VEvent.prototype.reply = function(fromuser, status, options) {
    var resp = this.clone(true);
    options = options || {};

    if(status === true || status === undefined)
        status = 'ACCEPTED';
    else if(status === false)
        status = 'DECLINED';

    resp.setProperty('ATTENDEE', fromuser, {
        'PARTSTAT': status,
        'CN': options['CN'] || fromuser
    });

    resp.setProperty('DTSTAMP', new Date());
    resp.setProperty('LAST-MODIFIED', new Date());

    var ics = new iCalendar();
    // TODO: Support REFRESH/COUNTER
    ics.addProperty('METHOD', 'REPLY');

    // Copy VTIMEZONE components...
    if(this.calendar)
        ics.addComponents(this.calendar.getComponents('VTIMEZONE'));

    ics.addComponent(resp);

    return ics;
}


schema.VEVENT = {
    factory: VEvent,
    valid_properties: [],
    required_properties: ['DTSTAMP','UID'],
    valid_children: [],
    required_children: []
};

},
"Z2oMYNS": function(exports, module, require) {
// /Users/meettya/git_hub/node-icalendar/lib/timezone.js 
// Copyright (C) 2011 Tri Tech Computers Ltd.
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal in
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.
// 
// 

var assert = require('assert');
var util = require('util');

var CalendarObject = require('./base').CalendarObject;
var schema = require('./base').schema;

var RRule = require('./rrule').RRule;



var VTimezone = exports.VTimezone = function(calendar, tzid) {
    CalendarObject.call(this, calendar, 'VTIMEZONE');
    this.addProperty('TZID', tzid);
}
util.inherits(VTimezone, CalendarObject);

VTimezone.prototype.getRRule = function(section) {
    var comp = this.getComponents(section)[0];
    if(!comp || !comp.getPropertyValue('RRULE'))
        return null;

    return new RRule(comp.getPropertyValue('RRULE'),
        comp.getPropertyValue('DTSTART'),
        comp.getPropertyValue('DTEND'));
}

// Find the UTC offset for this timezone for a given date, which can
// be supplied as a Date object or an array of date components.
//
// NB: Supplying the parameter as a Date object can lead to problems, as there
//     is no way to represent 0200 on the day DST comes into effect.
VTimezone.prototype.getOffsetForDate = function(dt) {
    if(!this.getComponents('DAYLIGHT').length)
        return this.getComponents('STANDARD')[0].getPropertyValue('TZOFFSETTO');

    // Right now we're only supporting a single element
    assert.equal(1, this.components['STANDARD'].length);
    assert.equal(1, this.components['DAYLIGHT'].length);

    var next_std = this.getRRule('STANDARD');
    var next_dst = this.getRRule('DAYLIGHT'); 
    if (next_std === null || next_dst === null) {
        var comp = this.getComponents('STANDARD')[0];
        return comp.getPropertyValue('TZOFFSETTO');
    }

    next_std = next_std.next(dt);
    next_dst = next_dst.next(dt);

    // TODO: Using prevOccurs would be a better solution
    // If the NEXT DST/STD crossover after `dt` is DST,
    //   then `dt` must be in STD and vice-versa
    return this.getComponents(next_dst < next_std ? 'STANDARD' : 'DAYLIGHT')[0]
            .getPropertyValue('TZOFFSETTO');
}

// Convert a parsed date in localtime to a UTC date object
VTimezone.prototype.fromLocalTime = function(dtarray) {
    var hrs = this.getOffsetForDate(dtarray);
    var min = hrs % 100;
    hrs = (hrs-min) / 100;

    return new Date(Date.UTC(dtarray[0], dtarray[1]-1, dtarray[2],
                    dtarray[3]-hrs, dtarray[4]-min, dtarray[5]));
}


schema.VTIMEZONE = {
    factory: VTimezone,
}

}};

var clinch_runtime_v2 = (function(exports){
/*!
 * Clinch - runtime lib
 * version 2
 * Copyright(c) 2013 Dmitrii Karpich <meettya@gmail.com>
 * MIT Licensed
 */

  var name_resolver_builder, internal_require_builder;

  name_resolver_builder = function(dependencies){
    return function(parent, name) {
      if (dependencies[parent] == null) {
        throw Error("no dependencies list for parent |" + parent + "|");
      }
      if (dependencies[parent][name] == null) {
        throw Error("no one module resolved, name - |" + name + "|, parent - |" + parent + "|");
      }
      return dependencies[parent][name];
    };
  };

  internal_require_builder = function(sources, name_resolver, modules_cache){
    var require, resolve_code, _this = this;

    require = function (name, parent) {
      var module_source, resolved_name;
      if (!(module_source = sources[name])) {
        resolved_name = name_resolver(parent, name);
        if (!(module_source = sources[resolved_name])) {
          throw Error("can`t find module source code: original_name - |" + name + "|, resolved_name - |" + resolved_name + "|");
        }
      }
      resolved_name = resolved_name != null ? resolved_name : name;
      if (modules_cache != null) {
        if (modules_cache[resolved_name] != null) {
          return modules_cache[resolved_name];
        }
        else {
          return modules_cache[resolved_name] = resolve_code(module_source, resolved_name);
        }
      }
      else {
        return resolve_code(module_source, resolved_name);
      }
    };

    resolve_code = function (module_source, resolved_name) {
      var exports, module, _ref;
      module_source.call(_this,exports = {}, module = {exports : exports}, function(mod_name) {
        return require(mod_name, resolved_name);
      });
      return (_ref = module.exports) != null ? _ref : exports;
    };

    return require;
  };

  // not require itself but builder
  exports.require_builder = function(dependencies, sources, modules_cache){
    return internal_require_builder.call(this, sources, name_resolver_builder(dependencies), modules_cache);
  };

  return exports;

})({});

require = clinch_runtime_v2.require_builder.call(this, dependencies, sources, modules_cache);

/* bundle export */
this.icalendar = require("Z14y8qH")
}).call(this);